#!/usr/bin/swift
import AppKit
import Foundation

// -------------------------
// Config
// -------------------------

enum Shape { case roundedSquare, pillWide }
let shape: Shape = .roundedSquare

let lightFillColor: NSColor = .black   // for Light variant
let darkFillColor:  NSColor = .white   // for Dark variant

let sizesPoints: [Int] = [16, 32, 128, 256, 512]

let lightSetName = "fnFlipAppIcon_Light.appiconset"
let darkSetName  = "fnFlipAppIcon_Dark.appiconset"

// -------------------------
// Local helpers (standalone)
// -------------------------

@inline(__always)
func aspectFitRect(imageSize: NSSize, in bounds: NSRect) -> NSRect {
    let iw = max(imageSize.width, 0.001)
    let ih = max(imageSize.height, 0.001)
    let iAR = iw / ih
    let bAR = bounds.width / max(bounds.height, 0.001)

    var w = bounds.width, h = bounds.height
    if iAR > bAR { h = w / iAR } else { w = h * iAR }
    return NSRect(x: bounds.midX - w/2, y: bounds.midY - h/2, width: w, height: h)
}

func makeTextGlyph(
    text: String,
    pointSize: CGFloat,
    weight: NSFont.Weight = .semibold,
    fontName: String? = nil,
    letterSpacing: CGFloat = 0,
    color: NSColor = .black
) -> NSImage {
    let font: NSFont = {
        if let fontName, let custom = NSFont(name: fontName, size: pointSize) { return custom }
        return NSFont.systemFont(ofSize: pointSize, weight: weight)
    }()
    let paragraph = NSMutableParagraphStyle()
    paragraph.alignment = .center

    let attrs: [NSAttributedString.Key: Any] = [
        .font: font,
        .foregroundColor: color,
        .kern: letterSpacing,
        .paragraphStyle: paragraph
    ]

    let attr = NSAttributedString(string: text, attributes: attrs)
    var size = attr.size()
    size.width = ceil(size.width) + 1
    size.height = ceil(size.height) + 1

    let img = NSImage(size: size)
    img.lockFocus()
    NSColor.clear.setFill()
    NSBezierPath(rect: NSRect(origin: .zero, size: size)).fill()
    attr.draw(in: NSRect(origin: .zero, size: size))
    img.unlockFocus()
    img.isTemplate = false
    return img
}

// -------------------------
// Rendering
// -------------------------

func drawOnIconInto(rep: NSBitmapImageRep, fillColor: NSColor, shape: Shape) {
    let side = CGFloat(rep.pixelsWide)

    // pill geometry
    let pillSize: NSSize
    let cornerRadius: CGFloat
    switch shape {
    case .roundedSquare:
        pillSize = NSSize(width: side * 0.78, height: side * 0.78)
        cornerRadius = side * 0.18
    case .pillWide:
        pillSize = NSSize(width: side * 0.82, height: side * 0.62)
        cornerRadius = side * 0.12
    }

    // typography
    let padding = side * 0.07
    let glyphPointSize = side * 0.38

    NSGraphicsContext.saveGraphicsState()
    if let ctx = NSGraphicsContext(bitmapImageRep: rep) {
        NSGraphicsContext.current = ctx
        ctx.imageInterpolation = .high

        // clear background
        NSColor.clear.setFill()
        NSBezierPath(rect: NSRect(x: 0, y: 0, width: side, height: side)).fill()

        // filled pill
        let pillRect = NSRect(
            x: (side - pillSize.width) / 2,
            y: (side - pillSize.height) / 2,
            width: pillSize.width,
            height: pillSize.height
        )
        let path = NSBezierPath(roundedRect: pillRect, xRadius: cornerRadius, yRadius: cornerRadius)
        fillColor.setFill()
        path.fill()

        // “fn” cutout
        let glyph = makeTextGlyph(text: "fn", pointSize: glyphPointSize, weight: .semibold)
        let target = pillRect.insetBy(dx: padding, dy: padding)
        let fit = aspectFitRect(imageSize: glyph.size, in: target)
        glyph.draw(in: fit, from: .zero, operation: .destinationOut, fraction: 1.0)
    }
    NSGraphicsContext.restoreGraphicsState()
}

func renderOnIconBitmap(sidePx: Int, fillColor: NSColor, shape: Shape) -> NSBitmapImageRep? {
    guard let rep = NSBitmapImageRep(
        bitmapDataPlanes: nil,
        pixelsWide: sidePx,
        pixelsHigh: sidePx,
        bitsPerSample: 8,
        samplesPerPixel: 4,
        hasAlpha: true,
        isPlanar: false,
        colorSpaceName: .deviceRGB,
        bytesPerRow: 0,
        bitsPerPixel: 0
    ) else { return nil }

    drawOnIconInto(rep: rep, fillColor: fillColor, shape: shape)
    return rep
}

// -------------------------
// Writing
// -------------------------

struct ImageJSON: Codable { let size, idiom, filename, scale: String }

func writeSet(folderName: String, fillColor: NSColor, shape: Shape) throws {
    let fm = FileManager.default
    let outDir = URL(fileURLWithPath: FileManager.default.currentDirectoryPath).appendingPathComponent(folderName, isDirectory: true)
    try? fm.removeItem(at: outDir)
    try fm.createDirectory(at: outDir, withIntermediateDirectories: true)

    var images: [ImageJSON] = []

    for pt in sizesPoints {
        for scale in [1, 2] {
            let px = pt * scale
            guard let rep = renderOnIconBitmap(sidePx: px, fillColor: fillColor, shape: shape),
                  let png = rep.representation(using: .png, properties: [:]) else {
                fputs("warn: failed to render \(pt)@\(scale)x\n", stderr)
                continue
            }
            let name = "icon_\(pt)x\(pt)@\(scale)x.png"
            try png.write(to: outDir.appendingPathComponent(name))
            images.append(.init(size: "\(pt)x\(pt)", idiom: "mac", filename: name, scale: "\(scale)x"))
            fputs("[\(folderName)] wrote \(name) \(rep.pixelsWide)x\(rep.pixelsHigh)\n", stderr)
        }
    }

    let contents: [String: Any] = [
        "images": images.map { ["size": $0.size, "idiom": $0.idiom, "filename": $0.filename, "scale": $0.scale] },
        "info": ["version": 1, "author": "xcode"]
    ]
    let data = try JSONSerialization.data(withJSONObject: contents, options: [.prettyPrinted, .sortedKeys])
    try data.write(to: outDir.appendingPathComponent("Contents.json"))
    fputs("[\(folderName)] wrote Contents.json\n", stderr)
}

// -------------------------
// Script entry
// -------------------------

do {
    try writeSet(folderName: lightSetName, fillColor: lightFillColor, shape: shape)
    try writeSet(folderName: darkSetName,  fillColor: darkFillColor,  shape: shape)
    print("done. Two .appiconset folders created in:", FileManager.default.currentDirectoryPath)
} catch {
    fputs("error: \(error)\n", stderr)
    exit(1)
}
