#!/usr/bin/swift

//
//  IconGen.swiftscript
//  fnFlip
//
//  Copyright (c) 2025 Erkin Ötleş
//  Licensed under: MIT + Commons Clause (see LICENSE in repo root)
//  SPDX-License-Identifier: MIT AND LicenseRef-Commons-Clause-1.0
//

import AppKit
import Foundation

// -------------------------
// Config
// -------------------------

enum Shape { case roundedSquare, pillWide }
let shape: Shape = .roundedSquare

let lightFillColor: NSColor = .black
let darkFillColor:  NSColor = .white

let sizesPoints: [Int] = [16, 32, 128, 256, 512]

let lightSetName = "fnFlipAppIcon_Light.appiconset"
let darkSetName  = "fnFlipAppIcon_Dark.appiconset"

// Installer backgrounds
let installerBGDir = "InstallerBackgrounds"
let installerBGBaseName = "fnflip-installer"
let installerBGSize = NSSize(width: 1024, height: 640)
let lightBG = NSColor(calibratedWhite: 0.97, alpha: 1.0)
let darkBG  = NSColor(calibratedWhite: 0.10, alpha: 1.0)
let lightText = NSColor(calibratedWhite: 0.20, alpha: 1.0)
let darkText  = NSColor(calibratedWhite: 0.95, alpha: 1.0)

// Mark sizing/position for background (bottom-left)
let installerMarkScale: CGFloat = 0.42   // relative to shortest edge
let installerMarkInsetX: CGFloat = 12.0  // px from left edge
let installerMarkInsetY: CGFloat = 12.0  // px from bottom edge
let drawInstallerTitleText = false       // keep the background clean

// -------------------------
// Helpers
// -------------------------

@inline(__always)
func aspectFitRect(imageSize: NSSize, in bounds: NSRect) -> NSRect {
    let iw = max(imageSize.width, 0.001)
    let ih = max(imageSize.height, 0.001)
    let iAR = iw / ih
    let bAR = bounds.width / max(bounds.height, 0.001)

    var w = bounds.width, h = bounds.height
    if iAR > bAR { h = w / iAR } else { w = h * iAR }
    return NSRect(x: bounds.midX - w/2, y: bounds.midY - h/2, width: w, height: h)
}

func makeTextGlyph(
    text: String,
    pointSize: CGFloat,
    weight: NSFont.Weight = .semibold,
    fontName: String? = nil,
    letterSpacing: CGFloat = 0,
    color: NSColor = .black
) -> NSImage {
    let font: NSFont = {
        if let fontName, let custom = NSFont(name: fontName, size: pointSize) { return custom }
        return NSFont.systemFont(ofSize: pointSize, weight: weight)
    }()
    let paragraph = NSMutableParagraphStyle()
    paragraph.alignment = .center

    let attrs: [NSAttributedString.Key: Any] = [
        .font: font, .foregroundColor: color, .kern: letterSpacing, .paragraphStyle: paragraph
    ]

    let attr = NSAttributedString(string: text, attributes: attrs)
    var size = attr.size()
    size.width = ceil(size.width) + 1
    size.height = ceil(size.height) + 1

    let img = NSImage(size: size)
    img.lockFocus()
    NSColor.clear.setFill()
    NSBezierPath(rect: NSRect(origin: .zero, size: size)).fill()
    attr.draw(in: NSRect(origin: .zero, size: size))
    img.unlockFocus()
    img.isTemplate = false
    return img
}

// -------------------------
// Icon rendering
// -------------------------

func drawOnIconInto(rep: NSBitmapImageRep, fillColor: NSColor, shape: Shape) {
    let side = CGFloat(rep.pixelsWide)

    let pillSize: NSSize
    let cornerRadius: CGFloat
    switch shape {
    case .roundedSquare:
        pillSize = NSSize(width: side * 0.78, height: side * 0.78)
        cornerRadius = side * 0.18
    case .pillWide:
        pillSize = NSSize(width: side * 0.82, height: side * 0.62)
        cornerRadius = side * 0.12
    }

    let padding = side * 0.07
    let glyphPointSize = side * 0.38

    NSGraphicsContext.saveGraphicsState()
    if let ctx = NSGraphicsContext(bitmapImageRep: rep) {
        NSGraphicsContext.current = ctx
        ctx.imageInterpolation = .high

        NSColor.clear.setFill()
        NSBezierPath(rect: NSRect(x: 0, y: 0, width: side, height: side)).fill()

        let pillRect = NSRect(
            x: (side - pillSize.width) / 2,
            y: (side - pillSize.height) / 2,
            width: pillSize.width,
            height: pillSize.height
        )
        let path = NSBezierPath(roundedRect: pillRect, xRadius: cornerRadius, yRadius: cornerRadius)
        fillColor.setFill()
        path.fill()

        let glyph = makeTextGlyph(text: "fn", pointSize: glyphPointSize, weight: .semibold)
        let target = pillRect.insetBy(dx: padding, dy: padding)
        let fit = aspectFitRect(imageSize: glyph.size, in: target)
        glyph.draw(in: fit, from: .zero, operation: .destinationOut, fraction: 1.0)
    }
    NSGraphicsContext.restoreGraphicsState()
}

func renderOnIconBitmap(sidePx: Int, fillColor: NSColor, shape: Shape) -> NSBitmapImageRep? {
    guard let rep = NSBitmapImageRep(
        bitmapDataPlanes: nil,
        pixelsWide: sidePx,
        pixelsHigh: sidePx,
        bitsPerSample: 8,
        samplesPerPixel: 4,
        hasAlpha: true,
        isPlanar: false,
        colorSpaceName: .deviceRGB,
        bytesPerRow: 0,
        bitsPerPixel: 0
    ) else { return nil }
    drawOnIconInto(rep: rep, fillColor: fillColor, shape: shape)
    return rep
}

// -------------------------
// Installer background rendering
// -------------------------

@discardableResult
func renderInstallerBackground(
    size: NSSize,
    fillColor: NSColor,
    bgColor: NSColor,
    titleColor: NSColor,
    outURL: URL
) -> Bool {
    let scale: CGFloat = 2.0
    let px = NSSize(width: size.width * scale, height: size.height * scale)

    guard let rep = NSBitmapImageRep(
        bitmapDataPlanes: nil,
        pixelsWide: Int(px.width),
        pixelsHigh: Int(px.height),
        bitsPerSample: 8,
        samplesPerPixel: 4,
        hasAlpha: true,
        isPlanar: false,
        colorSpaceName: .deviceRGB,
        bytesPerRow: 0,
        bitsPerPixel: 0
    ) else { return false }

    NSGraphicsContext.saveGraphicsState()
    if let ctx = NSGraphicsContext(bitmapImageRep: rep) {
        NSGraphicsContext.current = ctx
        ctx.cgContext.scaleBy(x: scale, y: scale)

        // fill
        bgColor.setFill()
        NSBezierPath(rect: NSRect(origin: .zero, size: size)).fill()

        // big mark, bottom-left
        let iconSide = min(size.width, size.height) * installerMarkScale
        if let iconRep = renderOnIconBitmap(sidePx: Int(iconSide * scale), fillColor: fillColor, shape: shape),
           let cg = iconRep.cgImage {
            let iconRect = NSRect(
                x: installerMarkInsetX,
                y: installerMarkInsetY,
                width: iconSide,
                height: iconSide
            )
            ctx.cgContext.interpolationQuality = .high
            ctx.cgContext.draw(cg, in: iconRect)
        }

        if drawInstallerTitleText {
            let title = "fnFlip"
            let font = NSFont.systemFont(ofSize: 40, weight: .semibold)
            let para = NSMutableParagraphStyle()
            para.alignment = .left
            let attrs: [NSAttributedString.Key: Any] = [
                .font: font, .foregroundColor: titleColor, .paragraphStyle: para
            ]
            let attr = NSAttributedString(string: title, attributes: attrs)
            let box = CGRect(x: installerMarkInsetX, y: installerMarkInsetY + 16 + iconSide, width: 600, height: 60)
            attr.draw(in: box)
        }
    }
    NSGraphicsContext.restoreGraphicsState()

    guard let png = rep.representation(using: .png, properties: [:]) else { return false }
    do { try png.write(to: outURL); fputs("[installer] wrote \(outURL.path)\n", stderr); return true }
    catch { fputs("error writing installer background: \(error)\n", stderr); return false }
}

// -------------------------
// Writing
// -------------------------

struct ImageJSON: Codable { let size, idiom, filename, scale: String }

func writeSet(folderName: String, fillColor: NSColor, shape: Shape) throws {
    let fm = FileManager.default
    let outDir = URL(fileURLWithPath: FileManager.default.currentDirectoryPath).appendingPathComponent(folderName, isDirectory: true)
    try? fm.removeItem(at: outDir)
    try fm.createDirectory(at: outDir, withIntermediateDirectories: true)

    var images: [ImageJSON] = []

    for pt in sizesPoints {
        for scale in [1, 2] {
            let px = pt * scale
            guard let rep = renderOnIconBitmap(sidePx: px, fillColor: fillColor, shape: shape),
                  let png = rep.representation(using: .png, properties: [:]) else {
                fputs("warn: failed to render \(pt)@\(scale)x\n", stderr)
                continue
            }
            let name = "icon_\(pt)x\(pt)@\(scale)x.png"
            try png.write(to: outDir.appendingPathComponent(name))
            images.append(.init(size: "\(pt)x\(pt)", idiom: "mac", filename: name, scale: "\(scale)x"))
            fputs("[\(folderName)] wrote \(name) \(rep.pixelsWide)x\(rep.pixelsHigh)\n", stderr)
        }
    }

    let contents: [String: Any] = [
        "images": images.map { ["size": $0.size, "idiom": $0.idiom, "filename": $0.filename, "scale": $0.scale] },
        "info": ["version": 1, "author": "xcode"]
    ]
    let data = try JSONSerialization.data(withJSONObject: contents, options: [.prettyPrinted, .sortedKeys])
    try data.write(to: outDir.appendingPathComponent("Contents.json"))
    fputs("[\(folderName)] wrote Contents.json\n", stderr)
}

// -------------------------
// Entry
// -------------------------

do {
    try writeSet(folderName: lightSetName, fillColor: lightFillColor, shape: shape)
    try writeSet(folderName: darkSetName,  fillColor: darkFillColor,  shape: shape)

    let cwd = URL(fileURLWithPath: FileManager.default.currentDirectoryPath)
    let bgDir = cwd.appendingPathComponent(installerBGDir, isDirectory: true)
    try? FileManager.default.removeItem(at: bgDir)
    try FileManager.default.createDirectory(at: bgDir, withIntermediateDirectories: true)

    _ = renderInstallerBackground(
        size: installerBGSize, fillColor: lightFillColor,
        bgColor: lightBG, titleColor: lightText,
        outURL: bgDir.appendingPathComponent("\(installerBGBaseName)-light.png")
    )
    _ = renderInstallerBackground(
        size: installerBGSize, fillColor: darkFillColor,
        bgColor: darkBG, titleColor: darkText,
        outURL: bgDir.appendingPathComponent("\(installerBGBaseName)-dark.png")
    )

    print("done. Two .appiconset folders and installer backgrounds created in:", FileManager.default.currentDirectoryPath)
} catch {
    fputs("error: \(error)\n", stderr)
    exit(1)
}
